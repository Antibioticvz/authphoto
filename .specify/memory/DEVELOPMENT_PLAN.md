# AuthPhoto â€” ĞŸĞ»Ğ°Ğ½ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸ Ğ¿Ñ€Ğ¾Ñ‚Ğ¾Ñ‚Ğ¸Ğ¿Ğ°
## Ğ›ÑƒÑ‡ÑˆĞ¸Ğµ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸, Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ°Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ, Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑĞµĞ¼Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°

**Ğ’ĞµÑ€ÑĞ¸Ñ:** 1.0 (Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ»Ğ°Ğ½)  
**Ğ”Ğ°Ñ‚Ğ°:** 16 Ğ½Ğ¾ÑĞ±Ñ€Ñ 2025  
**ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚Ñ‹:** Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° + Ğ¼Ğ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ°Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ + Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑĞµĞ¼Ğ¾ÑÑ‚ÑŒ  
**Ğ¯Ğ·Ñ‹Ğº:** TypeScript, React, NestJS

---

## ğŸ“‹ ĞĞ‘Ğ—ĞĞ  ĞŸĞ›ĞĞĞ

### Ğ¦ĞµĞ»Ğ¸
- âœ… **Ğ¡ĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ:** ĞŸÑ€Ğ¾Ñ‚Ğ¾Ñ‚Ğ¸Ğ¿ Ğ·Ğ° 2-3 Ğ½ĞµĞ´ĞµĞ»Ğ¸
- âœ… **ĞœĞ¾Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾ÑÑ‚ÑŒ:** ĞÑ‚Ğ·Ñ‹Ğ²Ñ‡Ğ¸Ğ²Ñ‹Ğ¹ Ğ´Ğ¸Ğ·Ğ°Ğ¹Ğ½ (mobile-first)
- âœ… **Ğ Ğ°ÑÑˆĞ¸Ñ€ÑĞµĞ¼Ğ¾ÑÑ‚ÑŒ:** ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ´Ğ»Ñ Ğ»ĞµĞ³ĞºĞ¾Ğ³Ğ¾ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ñ
- âœ… **ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾:** Ğ›ÑƒÑ‡ÑˆĞ¸Ğµ Ğ¿Ñ€Ğ°ĞºÑ‚Ğ¸ĞºĞ¸, Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ

### ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ
| ĞÑĞ¿ĞµĞºÑ‚ | Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ | ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ° |
|---|---|---|
| **Frontend Framework** | React 18 + Vite | Ğ‘Ñ‹ÑÑ‚Ñ€Ğ°Ñ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° + HMR |
| **Styling** | Tailwind CSS + shadcn/ui | Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ñ‹Ğµ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹, mobile-first |
| **State Management** | Zustand | ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ±Ğ¾Ğ¸Ğ»ĞµÑ€Ğ¿Ğ»ĞµĞ¹Ñ‚ |
| **Backend Framework** | NestJS | Enterprise-ready, scalable |
| **Package Manager** | pnpm | Ğ‘Ñ‹ÑÑ‚Ñ€ĞµĞµ npm, Ğ¼ĞµĞ½ÑŒÑˆĞµ Ğ´Ğ¸ÑĞºĞ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ¾ÑÑ‚Ñ€Ğ°Ğ½ÑÑ‚Ğ²Ğ° |
| **ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Frontend** | Feature-based + hooks + contexts | Ğ›ĞµĞ³ĞºĞ¾ Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑĞµÑ‚ÑÑ |
| **ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Backend** | ĞœĞ¾Ğ´ÑƒĞ»ÑŒĞ½Ğ°Ñ Ñ Ğ¸Ğ½ÑŠĞµĞºÑ†Ğ¸ĞµĞ¹ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹ | DI Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½ |
| **CSS Architecture** | BEM + Tailwind | Ğ¡Ğ¾Ğ³Ğ»Ğ°ÑĞ¾Ğ²Ğ°Ğ½Ğ½Ğ¾ÑÑ‚ÑŒ + ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ |
| **API Design** | REST Ñ Ğ²ĞµÑ€ÑĞ¸Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ | Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ğ¾, Ğ»ĞµĞ³ĞºĞ¾ Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑĞµÑ‚ÑÑ |

---

## ğŸ—ï¸ ĞĞ Ğ¥Ğ˜Ğ¢Ğ•ĞšĞ¢Ğ£Ğ Ğ Ğ˜ ĞŸĞĞ¢Ğ¢Ğ•Ğ ĞĞ« ĞŸĞ ĞĞ•ĞšĞ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ¯

### Ğ¤Ñ€Ğ¾Ğ½Ñ‚ĞµĞ½Ğ´: Feature-based Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°

```
src/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ camera/                    â† Feature: ĞºĞ°Ğ¼ĞµÑ€Ğ°
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ CameraCapture.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ PolygonOverlay.tsx
â”‚   â”‚   â”‚   â””â”€â”€ CameraPreview.tsx
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ useCamera.ts       â† Custom hook
â”‚   â”‚   â”‚   â”œâ”€â”€ useChallengePolygons.ts
â”‚   â”‚   â”‚   â””â”€â”€ useVideoCapture.ts
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ cameraService.ts   â† Ğ‘Ğ¸Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°
â”‚   â”‚   â”‚   â””â”€â”€ polygonDrawer.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ camera.types.ts    â† TypeScript Ñ‚Ğ¸Ğ¿Ñ‹
â”‚   â”‚   â””â”€â”€ store/
â”‚   â”‚       â””â”€â”€ cameraStore.ts     â† Zustand store
â”‚   â”‚
â”‚   â”œâ”€â”€ verification/               â† Feature: Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ ResultScreen.tsx
â”‚   â”‚   â”‚   â””â”€â”€ VerificationStatus.tsx
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â””â”€â”€ usePhotoVerification.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ verification.types.ts
â”‚   â”‚   â””â”€â”€ store/
â”‚   â”‚       â””â”€â”€ verificationStore.ts
â”‚   â”‚
â”‚   â””â”€â”€ auth/
â”‚       â”œâ”€â”€ hooks/
â”‚       â”‚   â””â”€â”€ useAuth.ts
â”‚       â”œâ”€â”€ services/
â”‚       â”‚   â””â”€â”€ authService.ts
â”‚       â””â”€â”€ types/
â”‚           â””â”€â”€ auth.types.ts
â”‚
â”œâ”€â”€ shared/                         â† ĞŸĞµÑ€ĞµĞ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼Ğ¾Ğµ
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Button/
â”‚   â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Button.module.css
â”‚   â”‚   â”‚   â””â”€â”€ Button.types.ts
â”‚   â”‚   â”œâ”€â”€ Card/
â”‚   â”‚   â”œâ”€â”€ Spinner/
â”‚   â”‚   â””â”€â”€ Modal/
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useMediaQuery.ts        â† Responsive
â”‚   â”‚   â”œâ”€â”€ useLocalStorage.ts
â”‚   â”‚   â””â”€â”€ useDebounce.ts
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ api.ts                  â† Axios instance
â”‚   â”‚   â”œâ”€â”€ crypto.ts               â† ĞšÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ
â”‚   â”‚   â””â”€â”€ logger.ts               â† Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ formatters.ts
â”‚   â”‚   â”œâ”€â”€ validators.ts
â”‚   â”‚   â””â”€â”€ helpers.ts
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”œâ”€â”€ api.types.ts
â”‚   â”‚   â””â”€â”€ common.types.ts
â”‚   â””â”€â”€ styles/
â”‚       â”œâ”€â”€ globals.css
â”‚       â”œâ”€â”€ tailwind.config.ts
â”‚       â””â”€â”€ variables.css
â”‚
â”œâ”€â”€ layouts/
â”‚   â”œâ”€â”€ MainLayout.tsx
â”‚   â””â”€â”€ CameraLayout.tsx
â”‚
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ HomePage.tsx
â”‚   â”œâ”€â”€ CameraPage.tsx
â”‚   â””â”€â”€ ResultPage.tsx
â”‚
â”œâ”€â”€ App.tsx
â”œâ”€â”€ main.tsx
â””â”€â”€ .env.example
```

### Ğ‘ÑĞºĞµĞ½Ğ´: ĞœĞ¾Ğ´ÑƒĞ»ÑŒĞ½Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ñ DI

```
src/
â”œâ”€â”€ main.ts                        â† Entry point
â”œâ”€â”€ app.module.ts                  â† Root module
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ configuration.ts           â† Environment config
â”‚   â”œâ”€â”€ database.config.ts
â”‚   â”œâ”€â”€ crypto.config.ts
â”‚   â””â”€â”€ logger.config.ts
â”‚
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ filters/
â”‚   â”‚   â”œâ”€â”€ http-exception.filter.ts
â”‚   â”‚   â””â”€â”€ validation.filter.ts
â”‚   â”œâ”€â”€ interceptors/
â”‚   â”‚   â”œâ”€â”€ logging.interceptor.ts
â”‚   â”‚   â”œâ”€â”€ transform.interceptor.ts
â”‚   â”‚   â””â”€â”€ cache.interceptor.ts
â”‚   â”œâ”€â”€ guards/
â”‚   â”‚   â”œâ”€â”€ api-key.guard.ts
â”‚   â”‚   â””â”€â”€ rate-limit.guard.ts
â”‚   â”œâ”€â”€ pipes/
â”‚   â”‚   â”œâ”€â”€ validation.pipe.ts
â”‚   â”‚   â””â”€â”€ parse-id.pipe.ts
â”‚   â”œâ”€â”€ decorators/
â”‚   â”‚   â”œâ”€â”€ api-response.decorator.ts
â”‚   â”‚   â””â”€â”€ public.decorator.ts
â”‚   â””â”€â”€ types/
â”‚       â””â”€â”€ common.types.ts
â”‚
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ crypto.service.ts      â† SHA-256, ECDSA
â”‚   â”‚   â”œâ”€â”€ logger.service.ts
â”‚   â”‚   â”œâ”€â”€ cache.service.ts       â† Redis wrapper
â”‚   â”‚   â””â”€â”€ file-storage.service.ts
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ helpers.ts
â”‚   â”‚   â””â”€â”€ validators.ts
â”‚   â””â”€â”€ types/
â”‚       â””â”€â”€ shared.types.ts
â”‚
â”œâ”€â”€ modules/
â”‚   â”‚
â”‚   â”œâ”€â”€ challenge/                 â† Challenge generation
â”‚   â”‚   â”œâ”€â”€ challenge.module.ts
â”‚   â”‚   â”œâ”€â”€ challenge.service.ts   â† Business logic
â”‚   â”‚   â”œâ”€â”€ challenge.controller.ts
â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”œâ”€â”€ create-challenge.dto.ts
â”‚   â”‚   â”‚   â””â”€â”€ challenge-response.dto.ts
â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â””â”€â”€ challenge.entity.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ challenge.types.ts
â”‚   â”‚   â””â”€â”€ __tests__/
â”‚   â”‚       â”œâ”€â”€ challenge.service.spec.ts
â”‚   â”‚       â””â”€â”€ challenge.controller.spec.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ capture/                   â† Photo capture
â”‚   â”‚   â”œâ”€â”€ capture.module.ts
â”‚   â”‚   â”œâ”€â”€ capture.service.ts
â”‚   â”‚   â”œâ”€â”€ capture.controller.ts
â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â””â”€â”€ capture-photo.dto.ts
â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”‚   â””â”€â”€ photo.entity.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ capture.types.ts
â”‚   â”‚   â””â”€â”€ __tests__/
â”‚   â”‚       â””â”€â”€ capture.service.spec.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ verification/              â† Photo verification
â”‚   â”‚   â”œâ”€â”€ verification.module.ts
â”‚   â”‚   â”œâ”€â”€ verification.service.ts
â”‚   â”‚   â”œâ”€â”€ verification.controller.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ verification.types.ts
â”‚   â”‚   â””â”€â”€ __tests__/
â”‚   â”‚       â””â”€â”€ verification.service.spec.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ storage/                   â† File storage
â”‚   â”‚   â”œâ”€â”€ storage.module.ts
â”‚   â”‚   â”œâ”€â”€ storage.service.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ storage.types.ts
â”‚   â”‚   â””â”€â”€ __tests__/
â”‚   â”‚       â””â”€â”€ storage.service.spec.ts
â”‚   â”‚
â”‚   â””â”€â”€ health/
â”‚       â”œâ”€â”€ health.module.ts
â”‚       â”œâ”€â”€ health.controller.ts
â”‚       â””â”€â”€ health.service.ts
â”‚
â”œâ”€â”€ photos/                        â† Photo storage (runtime)
â”‚   â””â”€â”€ .gitkeep
â”‚
â””â”€â”€ .env.example
```

---

## ğŸ¨ Ğ¤Ğ ĞĞĞ¢Ğ•ĞĞ”: Ğ›Ğ£Ğ§Ğ¨Ğ˜Ğ• ĞŸĞ ĞĞšĞ¢Ğ˜ĞšĞ˜

### 1. React ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ‹ (Functional Components + Hooks)

```typescript
// âœ… ĞŸĞ ĞĞ’Ğ˜Ğ›Ğ¬ĞĞ: Feature-based, reusable, well-typed
// src/features/camera/components/CameraCapture.tsx

import React, { useEffect, useRef, useState } from 'react';
import { useCamera } from '../hooks/useCamera';
import { useChallengePolygons } from '../hooks/useChallengePolygons';
import { PolygonOverlay } from './PolygonOverlay';
import { Button } from '@shared/components/Button';
import { Spinner } from '@shared/components/Spinner';
import type { CameraCaptureProps } from '../types/camera.types';
import styles from './CameraCapture.module.css';

/**
 * CameraCapture Component
 * 
 * Responsible for:
 * - Stream camera video
 * - Display challenge polygons
 * - Capture photo and video
 * 
 * @param clientId - Client identifier from query params
 * @param onCapture - Callback when photo is captured
 */
export const CameraCapture: React.FC<CameraCaptureProps> = ({
  clientId,
  onCapture
}) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  // Custom hooks for business logic
  const { 
    initCamera, 
    stopCamera, 
    takePhoto, 
    captureVideo,
    isCameraReady 
  } = useCamera(videoRef, canvasRef);

  const { 
    challenge, 
    isPolygonsReady, 
    drawPolygons 
  } = useChallengePolygons(clientId);

  // Initialize camera on mount
  useEffect(() => {
    const init = async () => {
      try {
        setIsLoading(true);
        await initCamera();
      } catch (err) {
        setError('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğµ Ğº ĞºĞ°Ğ¼ĞµÑ€Ğµ');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };

    init();

    return () => {
      stopCamera();
    };
  }, [initCamera, stopCamera]);

  // Animation loop for drawing
  useEffect(() => {
    if (!isCameraReady || !isPolygonsReady) return;

    const animationFrame = requestAnimationFrame(() => {
      if (canvasRef.current) {
        drawPolygons(canvasRef.current);
      }
    });

    return () => cancelAnimationFrame(animationFrame);
  }, [isCameraReady, isPolygonsReady, drawPolygons]);

  const handleCapture = async () => {
    if (!challenge) return;

    try {
      setIsLoading(true);
      setError(null);

      const photo = await takePhoto();
      const video = await captureVideo();

      onCapture({ photo, video, challenge });
    } catch (err) {
      setError('ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑÑŠÑ‘Ğ¼ĞºĞµ Ñ„Ğ¾Ñ‚Ğ¾');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className={styles.container}>
      {error && (
        <div className={styles.error} role="alert">
          {error}
        </div>
      )}

      <div className={styles.cameraWrapper}>
        <video
          ref={videoRef}
          className={styles.video}
          autoPlay
          playsInline
          muted
        />
        <canvas
          ref={canvasRef}
          className={styles.canvas}
        />
      </div>

      <Button
        onClick={handleCapture}
        disabled={isLoading || !isCameraReady}
        loading={isLoading}
        fullWidth
      >
        ğŸ“· Ğ¡Ğ½ÑÑ‚ÑŒ Ñ„Ğ¾Ñ‚Ğ¾
      </Button>
    </div>
  );
};

CameraCapture.displayName = 'CameraCapture';
```

### 2. Custom Hooks (DRY, Business Logic Separation)

```typescript
// src/features/camera/hooks/useCamera.ts
import { useCallback, useState, useRef } from 'react';

export const useCamera = (
  videoRef: React.RefObject<HTMLVideoElement>,
  canvasRef: React.RefObject<HTMLCanvasElement>
) => {
  const [isCameraReady, setIsCameraReady] = useState(false);
  const mediaStreamRef = useRef<MediaStream | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);

  const initCamera = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: 1280, height: 720, facingMode: 'user' }
      });

      if (videoRef.current) {
        videoRef.current.srcObject = stream;
      }

      mediaStreamRef.current = stream;
      setIsCameraReady(true);
    } catch (error) {
      throw new Error('Failed to access camera');
    }
  }, [videoRef]);

  const stopCamera = useCallback(() => {
    if (mediaStreamRef.current) {
      mediaStreamRef.current.getTracks().forEach(track => track.stop());
      setIsCameraReady(false);
    }
  }, []);

  const takePhoto = useCallback(async (): Promise<Blob> => {
    if (!canvasRef.current || !videoRef.current) {
      throw new Error('Canvas or video not available');
    }

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    if (!ctx) throw new Error('Could not get 2D context');

    canvas.width = videoRef.current.videoWidth;
    canvas.height = videoRef.current.videoHeight;

    ctx.drawImage(videoRef.current, 0, 0);

    return new Promise(resolve => {
      canvas.toBlob(blob => {
        if (!blob) throw new Error('Failed to create blob');
        resolve(blob);
      }, 'image/jpeg', 0.95);
    });
  }, []);

  const captureVideo = useCallback(async (): Promise<Blob> => {
    if (!canvasRef.current) {
      throw new Error('Canvas not available');
    }

    const stream = canvasRef.current.captureStream(30);
    const chunks: BlobPart[] = [];

    const mediaRecorder = new MediaRecorder(stream, {
      mimeType: 'video/webm'
    });

    mediaRecorder.ondataavailable = (e) => {
      chunks.push(e.data);
    };

    mediaRecorder.start();

    await new Promise(resolve => setTimeout(resolve, 2000));
    mediaRecorder.stop();

    return new Promise(resolve => {
      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'video/webm' });
        resolve(blob);
      };
    });
  }, []);

  return {
    initCamera,
    stopCamera,
    takePhoto,
    captureVideo,
    isCameraReady
  };
};
```

### 3. State Management (Zustand - Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹, Ğ¼Ğ¾Ñ‰Ğ½Ñ‹Ğ¹)

```typescript
// src/features/camera/store/cameraStore.ts
import { create } from 'zustand';
import type { CameraStoreState } from '../types/camera.types';

/**
 * Camera Store
 * Centralized state management for camera feature
 * Benefits:
 * - Simple, minimal boilerplate
 * - No Redux/Context Provider hell
 * - Easy to test
 */
export const useCameraStore = create<CameraStoreState>((set) => ({
  challenge: null,
  isChallengeLoading: false,
  error: null,

  // Actions
  setChallenge: (challenge) => set({ challenge }),
  setChallengeLoading: (loading) => set({ isChallengeLoading: loading }),
  setError: (error) => set({ error }),

  // Reset
  reset: () => set({
    challenge: null,
    isChallengeLoading: false,
    error: null
  })
}));
```

### 4. TypeScript (Strict mode, complete types)

```typescript
// src/features/camera/types/camera.types.ts
import type { Challenge } from '@shared/types/api.types';

export interface CameraCaptureProps {
  clientId: string;
  onCapture: (data: CaptureData) => void;
  onError?: (error: Error) => void;
}

export interface CaptureData {
  photo: Blob;
  video: Blob;
  challenge: Challenge;
  timestamp: number;
}

export interface CameraState {
  isReady: boolean;
  hasPermission: boolean;
  error: Error | null;
}

// Strict discriminated unions for better type safety
export type CameraEvent =
  | { type: 'INIT_START' }
  | { type: 'INIT_SUCCESS'; payload: CameraState }
  | { type: 'INIT_ERROR'; payload: Error }
  | { type: 'CAPTURE_START' }
  | { type: 'CAPTURE_SUCCESS'; payload: CaptureData }
  | { type: 'CAPTURE_ERROR'; payload: Error };
```

### 5. Mobile-First Responsive Design (Tailwind)

```typescript
// src/features/camera/components/CameraCapture.module.css
import { tv } from 'tailwind-variants';

export const cameraStyles = tv({
  slots: {
    container: 'w-full h-screen max-h-screen flex flex-col gap-4 p-4 bg-black',
    cameraWrapper: 'flex-1 relative rounded-xl overflow-hidden shadow-lg',
    canvas: 'w-full h-full object-cover',
    video: 'hidden',
    button: 'sticky bottom-0 w-full',
    error: 'bg-red-500/90 text-white p-4 rounded-lg text-sm text-center'
  },
  variants: {
    isPortrait: {
      true: {
        container: 'portrait:h-screen landscape:h-auto'
      }
    },
    isLoading: {
      true: {
        button: 'opacity-50 cursor-not-allowed'
      }
    }
  }
});

// Usage with media queries
// Mobile: 100% width, full height
// Tablet: max-width 600px, centered
// Desktop: max-width 800px, centered
```

### 6. API Service (Centralized, Singleton)

```typescript
// src/shared/services/api.ts
import axios, { AxiosInstance } from 'axios';
import type { ApiResponse } from '@shared/types/api.types';

class ApiClient {
  private static instance: AxiosInstance;

  static getInstance(): AxiosInstance {
    if (!this.instance) {
      this.instance = axios.create({
        baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3000/api/v1',
        timeout: 30000,
        headers: {
          'Content-Type': 'application/json'
        }
      });

      // Response interceptor
      this.instance.interceptors.response.use(
        (response) => response.data,
        (error) => {
          // Global error handling
          console.error('API Error:', error);
          throw error;
        }
      );
    }

    return this.instance;
  }
}

export const api = ApiClient.getInstance();

// Usage
export const challengeApi = {
  getChallenge: (clientId: string) =>
    api.get<ApiResponse<Challenge>>('/challenge', { params: { clientId } }),

  postCapture: (formData: FormData) =>
    api.post<ApiResponse<CaptureResult>>('/capture', formData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    })
};
```

### 7. Error Handling (Centralized)

```typescript
// src/shared/utils/errors.ts
export class AppError extends Error {
  constructor(
    public code: string,
    message: string,
    public statusCode: number = 500
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export class CameraError extends AppError {
  constructor(message: string) {
    super('CAMERA_ERROR', message, 400);
  }
}

export class ValidationError extends AppError {
  constructor(message: string) {
    super('VALIDATION_ERROR', message, 400);
  }
}

// Usage in error boundary
export const ErrorBoundary: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <ErrorBoundaryComponent
      FallbackComponent={({ error, reset }) => (
        <div className="error-container">
          <h1>ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ°</h1>
          <p>{error.message}</p>
          <button onClick={reset}>ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑĞ½Ğ¾Ğ²Ğ°</button>
        </div>
      )}
    >
      {children}
    </ErrorBoundaryComponent>
  );
};
```

---

## âš™ï¸ Ğ‘Ğ­ĞšĞ•ĞĞ”: Ğ›Ğ£Ğ§Ğ¨Ğ˜Ğ• ĞŸĞ ĞĞšĞ¢Ğ˜ĞšĞ˜

### 1. ĞœĞ¾Ğ´ÑƒĞ»ÑŒĞ½Ğ°Ñ Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° (NestJS)

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ChallengeModule } from './modules/challenge/challenge.module';
import { CaptureModule } from './modules/capture/capture.module';
import { VerificationModule } from './modules/verification/verification.module';
import { SharedModule } from './shared/shared.module';

@Module({
  imports: [
    SharedModule,      // Global providers (logger, cache, etc)
    ChallengeModule,
    CaptureModule,
    VerificationModule
  ],
  controllers: [],
  providers: []
})
export class AppModule {}
```

### 2. Dependency Injection (NestJS built-in)

```typescript
// src/modules/challenge/challenge.service.ts
import { Injectable } from '@nestjs/common';
import { LoggerService } from '@shared/services/logger.service';
import { CryptoService } from '@shared/services/crypto.service';
import { CacheService } from '@shared/services/cache.service';

/**
 * ChallengeService
 * Manages challenge generation and validation
 * 
 * Injected dependencies:
 * - LoggerService: logging
 * - CryptoService: random generation
 * - CacheService: TTL storage
 */
@Injectable()
export class ChallengeService {
  constructor(
    private readonly logger: LoggerService,
    private readonly crypto: CryptoService,
    private readonly cache: CacheService
  ) {}

  async generateChallenge(clientId: string) {
    this.logger.debug(`Generating challenge for client: ${clientId}`);

    const challenge = {
      challengeId: this.crypto.generateUUID(),
      nonce: this.crypto.generateNonce(),
      polygons: this.generateRandomPolygons(),
      expiry: Date.now() + 30_000, // 30 seconds TTL
      createdAt: Date.now()
    };

    // Cache with TTL
    await this.cache.set(
      `challenge:${challenge.challengeId}`,
      challenge,
      { ttl: 30 } // seconds
    );

    return challenge;
  }

  private generateRandomPolygons() {
    // Implementation here
  }
}
```

### 3. DTO Pattern (Data Validation)

```typescript
// src/modules/capture/dto/capture-photo.dto.ts
import { IsString, IsNotEmpty, MaxLength, IsBase64 } from 'class-validator';

/**
 * DTO for photo capture
 * Automatically validated by NestJS pipes
 */
export class CapturePhotoDto {
  @IsString()
  @IsNotEmpty()
  @MaxLength(500)
  message: string;

  @IsString()
  @IsNotEmpty()
  challengeId: string;

  @IsString()
  @IsNotEmpty()
  clientId: string;

  @IsBase64()
  @IsNotEmpty()
  videoBase64: string;

  @IsString()
  @IsNotEmpty()
  videoHash: string;
}

// Auto-validation in controller
@Post('capture')
async capture(@Body() dto: CapturePhotoDto, @UploadedFile() photo: Express.Multer.File) {
  // DTO is automatically validated before reaching this method
  // If validation fails, 400 error is thrown automatically
}
```

### 4. Error Handling (Filters)

```typescript
// src/common/filters/http-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger
} from '@nestjs/common';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();

    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let message = 'Internal server error';

    if (exception instanceof HttpException) {
      status = exception.getStatus();
      message = exception.getResponse()['message'] || exception.message;
    } else if (exception instanceof Error) {
      message = exception.message;
    }

    this.logger.error(`Exception: ${message}`, exception);

    response.status(status).json({
      status: 'error',
      statusCode: status,
      message,
      timestamp: new Date().toISOString()
    });
  }
}
```

### 5. Logging (Structured)

```typescript
// src/shared/services/logger.service.ts
import { Injectable, LoggerService as NestLoggerService } from '@nestjs/common';

@Injectable()
export class LoggerService implements NestLoggerService {
  log(message: string, context?: string) {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'INFO',
      context,
      message
    }));
  }

  error(message: string, trace?: string, context?: string) {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'ERROR',
      context,
      message,
      trace
    }));
  }

  debug(message: string, context?: string) {
    if (process.env.DEBUG) {
      console.debug(JSON.stringify({
        timestamp: new Date().toISOString(),
        level: 'DEBUG',
        context,
        message
      }));
    }
  }
}
```

### 6. API Response Format (Consistent)

```typescript
// src/shared/types/api.types.ts
export interface ApiResponse<T> {
  status: 'success' | 'error';
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: Record<string, unknown>;
  };
  timestamp: string;
}

// src/common/interceptors/transform.interceptor.ts
@Injectable()
export class TransformInterceptor<T> implements NestInterceptor<T, ApiResponse<T>> {
  intercept(
    context: ExecutionContext,
    next: CallHandler<T>
  ): Observable<ApiResponse<T>> {
    return next.handle().pipe(
      map(data => ({
        status: 'success',
        data,
        timestamp: new Date().toISOString()
      }))
    );
  }
}
```

### 7. Testing (Unit + Integration)

```typescript
// src/modules/challenge/challenge.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { ChallengeService } from './challenge.service';
import { CryptoService } from '@shared/services/crypto.service';
import { CacheService } from '@shared/services/cache.service';
import { LoggerService } from '@shared/services/logger.service';

describe('ChallengeService', () => {
  let service: ChallengeService;
  let cryptoService: CryptoService;
  let cacheService: CacheService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ChallengeService,
        {
          provide: CryptoService,
          useValue: {
            generateUUID: jest.fn(() => 'test-uuid'),
            generateNonce: jest.fn(() => 'test-nonce')
          }
        },
        {
          provide: CacheService,
          useValue: {
            set: jest.fn()
          }
        },
        {
          provide: LoggerService,
          useValue: { debug: jest.fn() }
        }
      ]
    }).compile();

    service = module.get<ChallengeService>(ChallengeService);
    cryptoService = module.get<CryptoService>(CryptoService);
    cacheService = module.get<CacheService>(CacheService);
  });

  describe('generateChallenge', () => {
    it('should generate challenge with correct structure', async () => {
      const result = await service.generateChallenge('client-123');

      expect(result).toHaveProperty('challengeId');
      expect(result).toHaveProperty('nonce');
      expect(result).toHaveProperty('polygons');
      expect(result).toHaveProperty('expiry');
      expect(result.expiry).toBe(Date.now() + 30_000);
    });

    it('should cache challenge', async () => {
      await service.generateChallenge('client-123');

      expect(cacheService.set).toHaveBeenCalled();
    });
  });
});
```

---

## ğŸ“± ĞœĞĞ‘Ğ˜Ğ›Ğ¬ĞĞĞ¯ ĞĞŸĞ¢Ğ˜ĞœĞ˜Ğ—ĞĞ¦Ğ˜Ğ¯

### 1. Viewport Configuration

```html
<!-- index.html -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no" />
<meta name="theme-color" content="#1f2937" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
```

### 2. Mobile-First CSS

```css
/* Mobile First Approach */

/* Mobile (default) */
.container {
  width: 100%;
  padding: 1rem;
  font-size: 16px; /* Prevent zoom on input focus */
}

.button {
  width: 100%;
  padding: 1rem;
  font-size: 16px; /* Prevent zoom */
  min-height: 44px; /* iOS touch target */
}

.camera-wrapper {
  aspect-ratio: 16 / 9;
  max-height: 80vh;
}

/* Tablet */
@media (min-width: 768px) {
  .container {
    max-width: 600px;
    margin: 0 auto;
  }

  .button {
    width: auto;
    min-width: 200px;
  }
}

/* Desktop */
@media (min-width: 1024px) {
  .container {
    max-width: 800px;
  }
}
```

### 3. Performance Optimization

```typescript
// Code splitting - lazy load features
const CameraPage = lazy(() => import('@pages/CameraPage'));
const ResultPage = lazy(() => import('@pages/ResultPage'));

// Suspense with loading state
<Suspense fallback={<Spinner />}>
  <CameraPage />
</Suspense>

// Image optimization - use WebP with fallback
<picture>
  <source srcSet="/logo.webp" type="image/webp" />
  <img src="/logo.png" alt="Logo" />
</picture>

// Debounce expensive operations
const debouncedSearch = useDebounce((query: string) => {
  // Search logic
}, 500);
```

### 4. Battery & Data Optimization

```typescript
// Stop unnecessary animations on low-power mode
const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

if (!prefersReducedMotion) {
  // Use animations
  animate();
} else {
  // Use static state instead
  applyStaticState();
}

// Reduce video quality on slow connections
const connection = navigator.connection || navigator.mozConnection;
const effectiveType = connection?.effectiveType; // '4g' | '3g' | '2g'

if (effectiveType === '2g' || effectiveType === '3g') {
  // Lower resolution video
  videoSettings = { width: 640, height: 480 };
}
```

---

## ğŸ§ª Ğ¢Ğ•Ğ¡Ğ¢Ğ˜Ğ ĞĞ’ĞĞĞ˜Ğ•

### Frontend Testing Strategy

```typescript
// Unit tests (Jest)
// - Services
// - Utilities
// - Hooks

// Component tests (Vitest + React Testing Library)
// - User interactions
// - State changes
// - Props rendering

describe('CameraCapture', () => {
  it('should render button', () => {
    const { getByRole } = render(<CameraCapture clientId="test" />);
    expect(getByRole('button')).toBeInTheDocument();
  });

  it('should call onCapture when button is clicked', async () => {
    const onCapture = jest.fn();
    const { getByRole } = render(
      <CameraCapture clientId="test" onCapture={onCapture} />
    );

    const button = getByRole('button');
    fireEvent.click(button);

    await waitFor(() => {
      expect(onCapture).toHaveBeenCalled();
    });
  });
});

// E2E tests (Playwright)
// - Full user flows
// - Cross-browser compatibility
// - Mobile device testing
test('Full photo capture flow', async ({ page }) => {
  await page.goto('http://localhost:5173/?clientId=test');
  await page.getByRole('button', { name: /ÑĞ½ÑÑ‚ÑŒ Ñ„Ğ¾Ñ‚Ğ¾/i }).click();
  await expect(page).toHaveURL(/result/);
});
```

### Backend Testing Strategy

```typescript
// Unit tests - Services
describe('ChallengeService', () => {
  // Test business logic in isolation
});

// Integration tests - Controllers
describe('ChallengeController', () => {
  // Test HTTP endpoints with real module
});

// E2E tests - Full flow
describe('Photo Capture Flow', () => {
  it('should complete full capture flow', async () => {
    // 1. Get challenge
    // 2. Send photo + video
    // 3. Verify success
  });
});
```

---

## ğŸš€ Ğ ĞĞ—Ğ ĞĞ‘ĞĞ¢ĞšĞ ĞŸĞ ĞĞ•Ğ”Ğ•Ğ›Ğ¯Ğœ

### Week 1: Backend Core

- âœ… Challenge Service (polynomial generation)
- âœ… Capture Service (photo validation)
- âœ… API Endpoints (GET /challenge, POST /capture)
- âœ… Unit tests for services
- âœ… Error handling & logging

**Deliverable:** Working backend API

### Week 2: Frontend Core

- âœ… Camera component with polygon overlay
- âœ… Custom hooks (useCamera, useChallengePolygons)
- âœ… State management (Zustand)
- âœ… API integration
- âœ… Result screen

**Deliverable:** Working web app

### Week 3: Optimization & Polish

- âœ… Mobile responsiveness testing
- âœ… Performance optimization (code splitting, lazy loading)
- âœ… Error handling & user feedback
- âœ… Integration testing (full flows)
- âœ… Docker setup

**Deliverable:** Production-ready prototypeype

---

## ğŸ“¦ PACKAGE.JSON DEPENDENCIES

### Frontend
```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "zustand": "^4.4.0",
    "axios": "^1.6.0",
    "tailwindcss": "^3.3.0"
  },
  "devDependencies": {
    "vite": "^5.0.0",
    "@vitejs/plugin-react": "^4.2.0",
    "typescript": "^5.3.0",
    "vitest": "^1.0.0",
    "@testing-library/react": "^14.1.0",
    "@playwright/test": "^1.40.0"
  }
}
```

### Backend
```json
{
  "dependencies": {
    "@nestjs/common": "^10.2.0",
    "@nestjs/core": "^10.2.0",
    "@nestjs/platform-express": "^10.2.0",
    "class-validator": "^0.14.0",
    "class-transformer": "^0.5.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.2.0",
    "@nestjs/testing": "^10.2.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.0",
    "typescript": "^5.3.0"
  }
}
```

---

## ğŸ”„ GIT WORKFLOW

```bash
# Feature branches
git checkout -b feature/camera-component
git checkout -b feature/challenge-api
git checkout -b feature/mobile-optimization

# Commit conventions (Conventional Commits)
git commit -m "feat(camera): add polygon overlay"
git commit -m "fix(api): fix video hash validation"
git commit -m "docs(readme): update setup instructions"
git commit -m "test(challenge): add service tests"

# Merge strategy
git pull origin main
git rebase main
git push origin feature/camera-component
# Create Pull Request with detailed description
# Require code review before merge
```

---

## ğŸ“‹ QUALITY CHECKLIST

ĞŸĞµÑ€ĞµĞ´ ĞºĞ°Ğ¶Ğ´Ñ‹Ğ¼ merge Ğ² main:

- âœ… Ğ’ÑĞµ Ñ‚ĞµÑÑ‚Ñ‹ Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´ÑÑ‚ (unit + integration)
- âœ… Code coverage > 80%
- âœ… No console.log (except logging service)
- âœ… No TypeScript errors
- âœ… ESLint passed
- âœ… Code reviewed (min 1 approval)
- âœ… Mobile tested
- âœ… Performance checked (Lighthouse > 90)

---

## ğŸ¯ SUMMARY

**ĞšĞ»ÑÑ‡ĞµĞ²Ñ‹Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ Ğ´Ğ»Ñ Ğ±Ñ‹ÑÑ‚Ñ€Ğ¾Ğ¹, Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑĞµĞ¼Ğ¾Ğ¹ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸:**

| ĞÑĞ¿ĞµĞºÑ‚ | Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ | ĞŸÑ€ĞµĞ¸Ğ¼ÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾ |
|---|---|---|
| **Architecture** | Feature-based (frontend) + Modular DI (backend) | Ğ›ĞµĞ³ĞºĞ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğµ Ñ„Ğ¸Ñ‡Ğ¸ |
| **State** | Zustand | ĞœĞ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ±Ğ¾Ğ¸Ğ»ĞµÑ€Ğ¿Ğ»ĞµĞ¹Ñ‚ vs Redux |
| **API** | Singleton axios instance | Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ |
| **Styling** | Tailwind + mobile-first | Ğ‘Ñ‹ÑÑ‚Ñ€Ğ¾, responsive, consistent |
| **Testing** | Vitest + Jest + Playwright | ĞŸĞ¾Ğ»Ğ½Ğ¾Ğµ Ğ¿Ğ¾ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ |
| **Performance** | Code splitting, lazy loading | Ğ‘Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ initial load |
| **Mobile** | Viewport meta + responsive CSS | ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ÑÑ Ğ²ĞµĞ·Ğ´Ğµ |
| **Deployment** | Docker + docker-compose | Easy production setup |

Ğ­Ñ‚Ğ° Ğ°Ñ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»Ğ¸Ñ‚ Ğ²Ğ°Ğ¼ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ‚Ğ¾Ñ‚Ğ¸Ğ¿ Ğ·Ğ° 2-3 Ğ½ĞµĞ´ĞµĞ»Ğ¸ Ğ¸ Ğ»ĞµĞ³ĞºĞ¾ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.
